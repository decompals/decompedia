---
title: Common Terminology
description: Common terms used in the context of decompilation.
published: false
date: 2025-02-22T04:09:22.098Z
tags: shiftability, glossary
editor: markdown
dateCreated: 2025-02-22T04:09:22.098Z
---



<!-- LOL i am not a good writer >.< --> 
<!-- i am NOT an expert in this, i am a NOVICE --> 
this is a DRAFT 

WIP


# Common Terminology
- Shiftability
    ## <!-- Bad --> Definition
    Shiftability is the ability to safely shift code around an executable without changing the behavior of the code at all. Shiftability allows changing the order of functions, adding or removing functions, and adding or removing TUs (source files). It is useful for modifying applications, i.e. developing mods.
    ## Situation
    so, um... when you program code, you will have pointers. Usually, these pointers are relative to other pointers, e.g. `pFoo = &bar->baz` This forms like a tree of pointers, and the root of the tree is of interest. The root is not relative to another pointer, instead it is absolute. It could come from malloc, which does not affect shiftability. <!-- (TODO: maybe add code exmaples for these.) --> Or, it could come from a static variable. Static variables _do_ affect shiftability, causing problems: they have a fixed, static location in memory. Therefore, they have a fixed, constant address. <!-- (TODO: is this true? what are other case of hardcoded pointers) --> As a result, a program will use hardcoded pointer literals (e.g. `0x80001234`) to reference static variables. 
    ## Problem
    Problems arise when more code/data is inserted or removed before the static variable. This changes the location of the static variable; it _shifts_ the variable and its data. That invalidates the hardcoded pointers. Being hard-coded, static, unchanging constants, hardcoded pointers will still point to the old location.
    ### What's supposed to happen
    Object files are called "relocatable" object files. They can be relocated; moved around. Code can be shifted without problems. When compiling object files, references to static variables will become _relocation entries_. <!-- (TODO: is this true? what is it actually called) --> If one examines the .o file generated by the compiler using a tool like `objdump`, they will <!-- (TODO: will they tho? what is a compiler/platform agnostic way to phrase this?) --> see things liek `RELOC_PPC32`; these are relocation entries. <!-- (TODO: examle. use vabolds dtk training framework to make an example?) --> Then, when the linker combines the `.o` object files into a `.elf` executable file, the linker will perform _relocation resolution_. The linker will pick an address for the static variable, and use that address to replace all the associated relocation entries. So the final `.elf` executable is _not relocatable_.  See <!-- (TODO: find a reference that doens't suck and actually makes some sense) -->.
    ### What happens
    The first step of decompiling is splitting, see <!-- [splitting](TODO maybe link the melee page, it has a good explanatin. maybe split that section to its own article??) -->. Splitting undoes the linker's work. However, undoing relocation resolution isn't as straightforward. Short of fully decompiling and matching the entire prgram, there is no way to 100% guarantee that we have properly undone the relocation resolution step. In other words, shiftability cannot be proven without 100% OK. <!-- (TODO: is this true?) --> This is because relocation resolution is a lossy process. It erases information about the original data.  If a program's code has:
    ```cpp
    const foo = 0x80001234
    static bar = "some data"
    printf("%d", foo);
    printf(bar);
    ```
    then looking at the final executable, how do we know `foo` is just a literal value and does not come from a relocation entry, but `&bar` *does* come from a relocation entry?
    <!-- TODO: I don't think this example is good or correct. --> We don't! And thus, problems occur.

    ## Fixing
    We must undo the relocation, and convert hardcoded pointers back to relocations. So first: find hardcoded pointers, and second: give them to your splitter so it can turn them back into relocation entries.
    ### when using [encounter/dtk](https://github.com/encounter/decomp-toolkit)
    encounter's decomp-toolkit for GC/Wii includes a splitter that tries to automatically detect relocations and undo relocation resolution. Thus, it tries to achieve perfect shiftablity automatically. However, sometimes it misses some relocations. Sometimes it fakes relocations, erroneously converting normal data into relocations. So, we have to use dtk's `noreloc` attribute to tell it not to treat normal data as a hardcoded pointer. <!-- (TODO: mayb add example of a string or somethign that looks liek a pointer. or jsut grep "noreloc" accross dtk projects to find examples.) -->

WIP
- Matching
- Regalloc
- Regswap
- Operand Swap
- [Scheduling](https://en.wikipedia.org/wiki/Instruction_scheduling)

-  "Compiler Memes"
    - Const memes
        - (not) making things const can make the compiler do things
    - bss memes
        - idk anythin about this
    - peephole memes
        - mwcc `#pragma peephole`
        - idk anythin about this
# Platform-Specific terminology
...todo...