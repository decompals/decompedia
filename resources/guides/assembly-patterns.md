---
title: Assembly Patterns
description: 
published: true
date: 2026-02-15T19:40:06.916Z
tags: 
editor: markdown
dateCreated: 2025-04-27T20:47:35.791Z
---

# Header
As C and C++ are structured languages, the assembly they get compiled to will exhibit some common patterns. Furthermore, certain operations will be consistently optimised in a certain way, giving rise to more patterns.

## Divide and multiply by 2

Assembly:
> andi    v0,a1,0xfffe

C code:
> unsigned short my_array[9];
>
> my_array[i / 2]

To index an array of 2-byte values (here, unsigned shorts), the index is multiplied by two. The code logic happens to require that the index be divided by two, first. The optimisation here does that in one step by ANDing with 0xFFFE (-2).

## Range check

Assembly:
> lhu     v1,0x10(sp)
> nop
> addiu   v0,v1,-0xe9
> sltiu   v0,v0,0xd
> bnez    v0,144

C code:
> if (wrk >= 0xE9 && wrk <= 0xF5)

One might be tempted to translate this as `if (wrk - 0xE9 < 0xD)`, but this is actually an optimised range check. 0xE9 is the minimum. The maximum can be found by `0xE9 + 0xD - 1`.

## Modulo (MW -O0)

Assembly:
> li      v0,0x20
> andi    v0,v1,0x1f

C code:
> wrk %= 0x20;

This pattern is typically found in unoptimised assembly generated by Metrowerks CodeWarrior. The `li` pseudo instruction loads the divisor used, which is immediately overwritten by the remainder, calculated using an `andi` instruction.

## Signed division

Assembly:
> bgez        $a0, .label1
> nop
> addiu       $a0, $a0, 0x7
> .label1:
> srl         $s0, $a0, 3

C code:
> wrk = wrk2 / 8;

If the divisor is a power of 2 (here, 8), you can shift  bits to the right. If the dividend is zero, a number one lower than the divisor is added to get a result consistent with C (which rounds down towards zero).

## Signed modulo

Assembly:
> bgez        $v0, .label1
>  addu       $v1, $v0, $zero
> addiu       $v1, $v0, 0x7
> .label1:
> sra         $v1, $v1, 3
> sll         $v1, $v1, 3
>  subu        $s0, $v0, $v1

C code:
> wrk = wrk2 % 8;

Same as above, but to get the remainder the quotient is multiplied by the divisor (by shifting bits to the left) is subtracted from the dividend.